#!/bin/bash


# Strict flag
# e - Exit if any error
# u - Treat unset variables as an error when substituting
# o pipefail - the return value of a pipeline is the psStatus of the last command to exit with a non-zero psStatus or zero if no command exited with a non-zero psStatus
# E - the ERR trap is inherited by shell functions
set -Eeuo pipefail

function finish() {
  printf "\n%s has finished\n" "${CLI_NAME}"
}
trap finish EXIT

# Execute a command
eval_command(){
  local EVAL_COMMAND=$1
  echo_info "Executing the command:\n$EVAL_COMMAND\n"
  eval "$EVAL_COMMAND"
}

cleaning_snapshot_dir(){

  echo_info "Cleaning the SNAPSHOT_ID directory"
  eval_command "rm -rf $DB_DUMP_SNAPSHOT_DIR"
  eval_command "mkdir -p $DB_DUMP_SNAPSHOT_DIR"
  echo_info "Directory cleaned"

}

validate_postgres_dump() {

    local dump_file="$1"

    # Check if file exists
    if [[ ! -f "$dump_file" ]]; then
        echo_err "Error: File $dump_file does not exist."
        return 1
    fi

    # Check file extension
    if [[ "${dump_file##*.}" != "dump" ]]; then
        echo_warn "Warning: File does not have .dump extension."
    fi

    # Check if file is empty
    if [[ ! -s "$dump_file" ]]; then
        echo_err "Error: File is empty."
        return 1
    fi

    # Check file format (custom or plain)
    if head -c 5 "$dump_file" | grep -q "PGDMP"; then
        echo_info "Info: File appears to be in custom format."
        format="custom"
    else
        echo_info "Info: File appears to be in plain text format."
        format="plain"
    fi

    # Validate file integrity
    if [[ "$format" == "custom" ]]; then
        if pg_restore -l "$dump_file" &>/dev/null; then
            echo_info "pg_restore can read the file structure."
        else
            echo_err "pg_restore cannot read the file structure. The dump may be corrupted."
            return 1
        fi
    else
        if grep -q "PostgreSQL database dump complete" "$dump_file"; then
            echo_info "File contains complete dump signature."
        else
            echo_warn "File does not contain the complete dump signature. It may be incomplete."
        fi
    fi

    # Check for specific PostgreSQL objects (example: tables)
    if [[ "$format" == "custom" ]]; then
        table_count=$(pg_restore -l "$dump_file" | grep -c "TABLE")
    else
        table_count=$(grep -c "CREATE TABLE" "$dump_file")
    fi
    echo_info "Info: Dump contains approximately $table_count tables."
    echo_info "Validation complete. The dump file appears to be valid."
    return 0
}

function backupCommandHelp() {

  echo ""
  echo "Usage of the backup command against the database (${CTL_DATABASE_NAME})"
  echo ""
  echo "The backup command creates or restore a dump of the database ${CTL_DATABASE_NAME}"
  echo ""
  echo "You can create 2 type of backup dump:"
  echo "  * sql"
  echo "  * archive"
  echo ""
  echo "   ${CLI_NAME} backup command [--option[=value] ...] arg1 arg2 ..."
  echo ""
  echo "where command is one of:"
  echo "     * create  - perform a backup"
  echo "     * restore - restore a backup"
  echo "     * ls      - list the backup dump files"
  echo "     * prune   - forget old snapshots with prune policy and perform dump file integrity checks"
  echo "     * fetch   snapshotId path     - fetch/get a file/dump by path"
  echo "     * help"
  echo ""

}
function backupRestoreHelp() {

  echo ""
  echo "Usage of the 'backup restore' command"
  echo ""
  echo "The 'backup restore' command restores a database from a SNAPSHOT_ID dump"
  echo ""
  echo "   ${CLI_NAME} backup restore [--db targetDbName] [--path dumpPath] snapshotId"
  echo ""
  echo "where:"
  echo "  * snapshotId          - the id of a SNAPSHOT_ID backup"
  echo "         (You can get them with the command 'backup ls')"
  echo "  * --db   targetDbName - the database target for the restoration"
  echo "         (by default: ${CTL_DATABASE_NAME})"
  echo "  * --path dumpPath     - the path to the dump file in a snapshot"
  echo ""

}

function backupCreateHelp() {

  echo ""
  echo "Usage of the 'backup create' command"
  echo ""
  echo "The 'backup create' command creates a SNAPSHOT_ID of the database ${CTL_DATABASE_NAME} in a dump format"
  echo ""
  echo "   ${CLI_NAME} backup create type"
  echo ""
  echo "where:"
  echo "  * type is the format of the dump:"
  echo "     * sql      - perform a sql backup dump (SQL file with statements)"
  echo "     * archive  - perform an archive dump (Archive format)"
  echo ""

}

function help() {

  echo ""
  echo "Usage of the cli ${CLI_NAME} against the database (${CTL_DATABASE_NAME})"
  echo ""
  echo "   ${CLI_NAME} command [--option[=value] ...] arg1 arg2 ..."
  echo ""
  echo "where command is one of:"
  echo "     * backup                   - create or restore a database backup"
  echo "     * db-ls                    - list the db in the postgres instance (cluster)"
  echo "     * db-extension-ls          - list the extensions installed"
  echo "     * db-conf                  - print the postgres.conf file"
  echo "     * job-ls                   - print the pg_cron jobs"
  echo "     * ps-status                - psStatus of the processes"
  echo "     * ps-ls                    - list the processes running"
  echo "     * ps-restart processName   - restart a process"
  echo "     * ps-start processName     - start a process"
  echo "     * help"
  echo ""

}

function psLs(){
  command="overmind ps"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"
}

function psLog(){
  if [ -z "${ARGS[0]}" ]; then
        echo_err 'The process name should be given as first argument'
        echo_err 'use the ps-ls command to get the available process name'
        exit 1
    fi
    process=${ARGS[0]}
    command="overmind log ${process}"
    echo_info "\nExecuting the command:\n$command\n"
    eval "$command"
    echo_info "$process log done"
}

function psRestart(){
  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The process name should be given as first argument'
      echo_err 'use the ps-ls command to get the available process name'
      exit 1
  fi
  process=${ARGS[0]}
  command="overmind restart ${process}"
  sleep 5 && overmind restart sql_exporter; cat /proc/1/fd/1 /proc/1/fd/2
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"
  echo_info "$process restarted"
}


## psStatus
#
# print every second the status of all process in supervisor
function psStatus(){
  while sleep 1; do
    if OUTPUT=$(supervisorctl status all); then
      # catch error or not (if the status is not running)
      # supervisorctl returns a -1 exit status
      :
    fi
    clear;
    echo "$OUTPUT"
  done
}


function backupRestoreCommand(){

  if [ -z "${ARGS[0]}" ]; then
      backupRestoreHelp
      echo_err 'The Snapshot Id should be given as first argument'
      echo_err "  * get one with the 'create ls' command"
      echo_err "  * or use 'latest' if you want to use the latest SNAPSHOT_ID"
      exit 1
  fi

  SNAPSHOT_ID=""
  TARGET_DB_NAME=$CTL_DATABASE_NAME
  DUMP_PATH=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--db)
        shift
        TARGET_DB_NAME=$1
        shift
        ;;
      -p|--path)
        shift
        DUMP_PATH=$1
        shift
        ;;
      *)
        if [ "$SNAPSHOT_ID" != "" ]; then
          backupRestoreHelp
          echo_err "Only one argument can be given: the snapshotId. We see 2: $SNAPSHOT_ID and $1"
          exit 1
        fi
        SNAPSHOT_ID=${1}
        shift
        ;;
    esac
  done


  echo_info "Creating the target restoration directory"
  RESTORE_DIR="$RESTORE_DIR_BASE/${SNAPSHOT_ID}"
  eval_command "mkdir -p $RESTORE_DIR_BASE"
  echo_info "Directory created"

  INCLUDE_PATH_PATTERN=$DB_DUMP_SNAPSHOT_DIR
  if [ "$DUMP_PATH" != "" ]; then
    INCLUDE_PATH_PATTERN=$DUMP_PATH
  fi
  echo_info "Fetching the backup dump from the SNAPSHOT_ID ${SNAPSHOT_ID} into the database (${TARGET_DB_NAME})"
  eval_command "restic restore --include ${INCLUDE_PATH_PATTERN} --target $RESTORE_DIR --verify ${SNAPSHOT_ID}"
  echo_info "Fetching done"

  if [ "$DUMP_PATH" == "" ]; then
    echo_info "Searching a valid dump file in the SNAPSHOT_ID ${SNAPSHOT_ID}"
    ARCHIVE_DUMP_FILE_TO_RESTORE="${RESTORE_DIR}/${DB_DUMP_ARCHIVE_FILE}"
    if [ -f  "$ARCHIVE_DUMP_FILE_TO_RESTORE" ]; then
        DUMP_FILE_TO_RESTORE=$ARCHIVE_DUMP_FILE_TO_RESTORE
        DUMP_FILE_TYPE=$ARCHIVE_DUMP_FORMAT
    else
      SQL_DUMP_FILE_TO_RESTORE="${RESTORE_DIR}/${DB_DUMP_SQL_FILE}"
      if [ ! -f  "$SQL_DUMP_FILE_TO_RESTORE" ]; then
        echo_err "We could not find any dump file to restore in the SNAPSHOT_ID ${SNAPSHOT_ID}"
        echo_err "  * No SQL dump found at $SQL_DUMP_FILE_TO_RESTORE"
        echo_err "  * No Archive dump found at ${ARCHIVE_DUMP_FILE_TO_RESTORE}"
        echo_err ""
        echo_err "You can give one with the  '--path' parameter"
        exit 1
      fi
      DUMP_FILE_TO_RESTORE=$SQL_DUMP_FILE_TO_RESTORE
      DUMP_FILE_TYPE=$SQL_DUMP_FORMAT
    fi
    echo_info "Dump file $DUMP_FILE_TO_RESTORE found"
  else
    DUMP_FILE_TO_RESTORE="${RESTORE_DIR}/${DUMP_PATH}"
    if [ ! -f  "$DUMP_FILE_TO_RESTORE" ]; then
        echo_err "The SNAPSHOT_ID ${SNAPSHOT_ID} does not contains the ${DUMP_PATH}"
        echo_err "  * No file found at $DUMP_FILE_TO_RESTORE"
        exit 1
    fi
    if echo "$DUMP_PATH" | grep -q '\.dump$';  then
      DUMP_FILE_TYPE=$ARCHIVE_DUMP_FORMAT
    else
      if ! echo "$DUMP_PATH" | grep -q '\.sql.gz$';  then
        echo_err "The dump file ($DUMP_PATH) is not an archive (.dump), nor a sql dump (.sql.gz)"
        exit 1
      fi
      DUMP_FILE_TYPE=$SQL_DUMP_FORMAT
    fi
  fi

  echo_info "Validating the dump file"
  validate_postgres_dump "${DUMP_FILE_TO_RESTORE}"

  echo_info "Restoring the database ${TARGET_DB_NAME} with the dump (${DUMP_FILE_TO_RESTORE})"
  echo_info "Checking if the database ${TARGET_DB_NAME} exists"
  if [ "$(psql -tAc "SELECT 1 FROM pg_database WHERE datname='${TARGET_DB_NAME}'")" == "1" ]; then
    echo_info "The database ${TARGET_DB_NAME} exits and should be dropped before restoration"
    echo_info "Dropping the database ${TARGET_DB_NAME} before restoration? (y/N)"
    read -r answer
    if [ "$answer" != "y" ]; then
        echo_info "Exiting..."
        exit 1
    fi
    eval_command "dropdb ${TARGET_DB_NAME} --force -i"
    echo_info "Dropping Done"
  else
    echo_info "The database does not exist"
  fi;

  echo_info "Creating an empty database ${TARGET_DB_NAME}"
  # load the output of pg_restore into a truly empty database (ie template0)
  eval_command "createdb -T template0 ${TARGET_DB_NAME}"
  echo_info "Database created"

  echo_info "Restoring the database"
  if [ "$DUMP_FILE_TYPE" == "$SQL_DUMP_FORMAT" ]; then
    eval_command "gunzip < ${DUMP_FILE_TO_RESTORE} | psql --set ON_ERROR_STOP=on --single-transaction ${TARGET_DB_NAME}";
  else
    # the -d option makes a direct connection with libpq
    # If the connection does not work, try with psql
    eval_command "pg_restore -d ${TARGET_DB_NAME} ${DUMP_FILE_TO_RESTORE}"
  fi
  echo_info "Restoration done"

  echo_info "Bye"

}


function backupCreateCommand(){

  # Check if at least one argument is provided
  if [[ $# -eq 0 ]]; then
      backupCreateHelp
      echo_err "No arguments provided."
      return 1
  fi

  # Cleaning the SNAPSHOT_ID directory
  clean_snaphost_dir

  # Assign the first argument to a string
  local DUMP_FORMAT=${1:-$SQL_DUMP_FORMAT}
  local DUMP_FILE;
  case "$DUMP_FORMAT" in
      "$SQL_DUMP_FORMAT")
        DUMP_FILE=${DB_DUMP_ARCHIVE_FILE}
        EVAL_COMMAND="pg_dump ${CTL_DATABASE_NAME} | gzip  > ${DUMP_FILE}"
        ;;
      "$ARCHIVE_DUMP_FORMAT")
        DUMP_FILE=${DB_DUMP_ARCHIVE_FILE}
        # F means format and c specify the custom format
        # https://www.postgresql.org/docs/current/app-pgdump.html
        EVAL_COMMAND="pg_dump --format=c ${CTL_DATABASE_NAME} > ${DUMP_FILE}"
        ;;
       *)
         backupCreateHelp
         echo_err "Dump format $DUMP_FORMAT unknown"
         return 1
  esac

  echo_info "Dumping the database (${CTL_DATABASE_NAME}) into the SNAPSHOT_ID directory"
  eval_command "$EVAL_COMMAND"
  echo_info "Done"

  echo_info "Creating a SNAPSHOT_ID"
  eval_command "restic backup ${DB_DUMP_SNAPSHOT_DIR}"
  echo_info "Snapshot done"

  echo_info "Backup done"

}

function dbDirDump(){

  echo_info "Dumping the database (${CTL_DATABASE_NAME}) at ${DB_DUMP_ARCHIVE_DIR}"
  echo_info "Removing ${DB_DUMP_ARCHIVE_DIR}"
  rm -f "${DB_DUMP_ARCHIVE_DIR}"/*
  if [ -d "${DB_DUMP_ARCHIVE_DIR}" ]; then
      rmdir "${DB_DUMP_ARCHIVE_DIR}"
  fi

  # F means format and d specify the directory format
  # https://www.postgresql.org/docs/current/app-pgdump.html
  command="pg_dump --format=d ${CTL_DATABASE_NAME} -f ${DB_DUMP_ARCHIVE_DIR}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Done"
  echo_info "Loading into Restic S3 repo (${PG_DUMP_DATA})"

  command="restic backup ${PG_DUMP_DATA}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Restic upload done"
  echo_info "Backup done"
}

function backupLsCommand(){
  restic find --long  "${PG_DUMP_DATA}"
}

function dumpFetch(){

  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The Snapshot Id should be given as first argument'
      echo_err 'use the dump-ls command to get the available SNAPSHOT_ID ids'
      # shellcheck disable=SC2016
      echo_err 'or use `latest` if you want to use the latest SNAPSHOT_ID'
      exit 1
  fi
  SNAPSHOT_ID=${ARGS[0]}
  if [ -z "${ARGS[1]}" ]; then
      echo_err 'A path should be given as second argument'
      exit 1
  fi
  path=${ARGS[1]}
  echo_info "Fetching the path (${path}) from the SNAPSHOT_ID id ${SNAPSHOT_ID}"

  command="restic restore --include ${path} --target $RESTORE_DIR_BASE --verify ${SNAPSHOT_ID}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  targetDumpFileInRestore="${RESTORE_DIR_BASE}${path}"
  echo_info "Fetch done"
  echo_info "The restored file is available at ${targetDumpFileInRestore}"

}

function walGRestore(){

  overmind stop postgres
  overmind restart postgres
  overmind log postgres
  stop_word="recovered"

  # 2 options: strace of snoops a tty
  # read the stdout (fd/1) and stderr (fd/2) of overmind (proc/1)
  # pb the PID on restart are not the same
  # https://github.com/tmux/tmux/wiki/Control-Mode/fd5e33023fe7c16cb573b954d05c70e16d225a9a#pane-output
  # debug the process (e.g. strace, dtrace/dtruss, gdb, lldb, ...)
  # strace works using the ptrace system call, so if ptrace isn’t allowed
  # ptrace needs to be allowed via a switch to the docker command (ie cap_add: SYS_PTRACE)
  # strace -e trace=write -s 1000 -p 1 2>&1 | while ....
  # ie prints write operation of the process (1000 length) specified by PID (-p 1)
  # https://unix.stackexchange.com/questions/58550/how-to-view-the-output-of-a-running-process-in-another-bash-session
  # watch which snoops a given tty, e.g.
  # watch /dev/pts/0
  # https://github.com/rapiz1/catp/
  # if you cat you just delete from the log the long line
  cat /proc/1/fd/1 /proc/1/fd/2 | while IFS= read -r line
  # you can write to them ls >/proc/1/fd/1
  # https://github.com/DarthSim/overmind/issues/111
  # cat /proc/20/fd/1 /proc/20/fd/2
  do
      echo "$line"
      if [[ "$line" == *"$stop_word"* ]]; then
          break
      fi
  done

}

function backupSqlCommand(){

    # Check if at least one argument is provided
    if [[ $# -eq 0 ]]; then
        backupCreateHelp
        echo_err "No arguments provided."
        return 1
    fi

    # Assign the first argument to a string
    local DUMP_FORMAT="$1"
    shift  # Remove the first argument from the argument list

    # Assign the rest of the arguments to an array
    local ARGS=()
    ARGS=("$@")
    case "$DUMP_FORMAT" in
        sql)
          backupSql
        ;;
   esac
}

function backupCommand(){

  # Check if at least one argument is provided
  if [[ $# -eq 0 ]]; then
      backupCommandHelp
      echo_err "No arguments provided."
      return 1
  fi

  # Assign the first argument to a string
  local COMMAND="$1"
  shift  # Remove the first argument from the argument list

  # Assign the rest of the arguments to an array
  local ARGS=()
  ARGS=("$@")

  case "$COMMAND" in
    create)
      backupCreateCommand "${ARGS[@]}"
      ;;
    restore)
      backupRestoreCommand "${ARGS[@]}"
      ;;
    db-backp-dir-dump)
      dbDirDump
      ;;
    fetch)
      dumpFetch
      ;;
    ls)
      backupLsCommand
      ;;
    prune)
      backupPruneCommand
      ;;
    *)
      echo "Unknown command ($COMMAND) found"
      exit 1
        ;;
  esac

}
function backupPruneCommand(){

  echo_info "Rolling the dump files (forget and prune)"
  command="restic forget --prune ${DBCTL_FORGET_POLICY:---keep-hourly 5 --keep-daily 7 --keep-weekly 5 --keep-monthly 12 --keep-yearly 3}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Data check with subset"
  COUNTER_FILE="$DATA_HOME/dbctl-check-subset-counter"
  COUNTER_TOTAL=${DBCTL_CHECK_SUBSET:-5}
  if [ ! -f "$COUNTER_FILE" ]; then
      echo 0 > "$COUNTER_FILE"
  fi
  counter=$(cat "$COUNTER_FILE")
  counter=$((counter + 1))
  if [ "$counter" -gt "$COUNTER_TOTAL" ]; then
      counter=1
  fi
  echo "$counter" > "$COUNTER_FILE"

  command="restic check --read-data-subset=$counter/$COUNTER_TOTAL"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Dump Prune done"
}

#################################
## Global Parameters
#################################
CTL_DATABASE_NAME=${POSTGRES_DB}
if [ -z "${CTL_DATABASE_NAME}" ]; then
  CTL_DATABASE_NAME=${POSTGRES_USER}
fi;
if [ -z "${CTL_DATABASE_NAME}" ]; then
  echo_err "The database could not be determined via POSTGRES_DB or POSTGRES_USER"
  exit 1;
fi;

## Dump parameter
PG_DUMP_DATA=${PG_DUMP_DATA:-}
if [[ ${PG_DUMP_DATA} == "" ]]; then
    echo_err "The PG_DUMP_DATA var is unknown"
    exit 1;
fi;
mkdir -p "$PG_DUMP_DATA"
###############################
# Constant for the dump format
###############################
SQL_DUMP_FORMAT=sql
ARCHIVE_DUMP_FORMAT=archive
###############################
# Constant for the dump files
###############################
# The SNAPSHOT_ID directory is the directory that restic snapshots.
# ie before every dump creation/restoration,
# the directory is cleaned to have only one dump at a time
DB_DUMP_SNAPSHOT_DIR="$PG_DUMP_DATA/SNAPSHOT_ID"
mkdir -p "$DB_DUMP_SNAPSHOT_DIR"
# All dump files start with this prefix path
DB_DUMP_PATH_PREFIX="$DB_DUMP_SNAPSHOT_DIR/dumpfile-db"
DB_DUMP_ARCHIVE_EXTENSION=".dump"
DB_DUMP_SQL_EXTENSION=".sql.gz"
DB_DUMP_SQL_FILE="$DB_DUMP_PATH_PREFIX-${CTL_DATABASE_NAME}$DB_DUMP_SQL_EXTENSION"
DB_DUMP_ARCHIVE_FILE="$DB_DUMP_PATH_PREFIX-${CTL_DATABASE_NAME}$DB_DUMP_ARCHIVE_EXTENSION"
DB_DUMP_ARCHIVE_DIR="$DB_DUMP_PATH_PREFIX-${CTL_DATABASE_NAME}"
# RESTORE_DIR_BASE where the files restored are going
RESTORE_DIR_BASE=/tmp


CLI_NAME=$(basename "$0") # Name of the cli
if [[ -z ${DBCTL_LOG_FILE} ]]; then
  echo_err "The DBCTL_LOG_FILE env is mandatory"
  exit 1
fi

#######################################
## Main
#######################################

if [[ $# -eq 0 ]]; then
  help
  echo_err 'No command was given.'
  exit 1
fi

# Assign the first argument to a string
COMMAND="$1"
shift  # Remove the first argument from the argument list

# Assign the rest of the arguments to an array
declare -a ARGS=()
ARGS=("$@")


#################################
## Start
#################################
echo
echo "${CLI_NAME^} ${COMMAND^}"
echo "-------------------------------------------"
echo ""
case ${COMMAND} in
backup)
  backupCommand "${ARGS[@]}"
  ;;
restore)
  backupRestoreCommand "${ARGS[@]}"
  ;;
db-ls)
  psql -c "\l"
  ;;
wal-ls)
  psql -c "select * from pg_stat_archiver"
#  psql -c "SELECT pg_switch_wal()"
  psql -c "SHOW archive_mode; SHOW archive_command"
  ;;
db-extension-ls)
  psql -c "\dx"
  ;;
ps-ls)
  psLs
  ;;
ps-restart)
  psRestart
  ;;
ps-status)
  psStatus
  ;;
ps-start)
  psStart
  ;;
ps-log)
  psLog
  ;;
db-conf)
  cat /etc/postgresql/postgresql.conf
  ;;
pg)
  pg_ctl "${OPTIONS[@]}"
  ;;
psql)
  psql "${OPTIONS[@]}"
  ;;
job-ls)
  EVAL_COMMAND="psql -c 'select * from cron.job_run_details order by start_time desc limit 5'"
  echo_info "Executing the command:\n$EVAL_COMMAND"
  eval "$EVAL_COMMAND"
  ;;
help)
  help
  ;;
*)
  help
  echo_err "The command $COMMAND is unknown"
  exit 1
  ;;
esac
