#!/bin/bash


# Strict flag
# e - Exit if any error
# u - Treat unset variables as an error when substituting
# o pipefail - the return value of a pipeline is the status of the last command to exit with a non-zero status or zero if no command exited with a non-zero status
# E - the ERR trap is inherited by shell functions
set -Eeuo pipefail

function finish() {
  printf "\n%s has finished\n" "${CLI_NAME}"
}
trap finish EXIT


function print_usage() {

  echo ""
  echo "Usage of the cli ${CLI_NAME} against the database (${CTL_DATABASE_NAME})"
  echo ""
  echo "   ${CLI_NAME} command [--option[=value] ...] arg1 arg2 ..."
  echo ""
  echo "where command is one of:"
  echo "     * help"
  echo "     * db-backup-sql-dump                                  - perform a sql database dump and a snapshot"
  echo "     * db-backup-sql-restore snapshotId [targetDbName]     - restore the sql database from a snapshot id into eventually another database"
  echo "     * db-backup-archive-dump                              - perform a database archive dump and a snapshot"
  echo "     * db-backup-archive-restore snapshotId [targetDbName] - restore a database archive dump from a snapshot id into eventually another database"
  echo "     * db-ls                            - list the db in the postgres instance (cluster)"
  echo "     * db-extension-ls                  - list the extensions installed"
  echo "     * db-conf                          - print the postgres.conf file"
  echo "     * dump-ls                          - list the dump files in the snapshots"
  echo "     * dump-prune                       - forget old snapshots with prune policy and perform dump file integrity checks"
  echo "     * dump-fetch snapshotId path       - fetch/get a file/dump by path"
  echo "     * ps-ls                            - list the processes running"
  echo "     * ps-restart processName           - restart a process"
  echo "     * ps-start processName             - start a process"
  echo "     * job-ls                           - print the pg_cron jobs"
  echo ""

}

function psLs(){
  command="overmind ps"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"
}

function psLog(){
  if [ -z "${ARGS[0]}" ]; then
        echo_err 'The process name should be given as first argument'
        echo_err 'use the ps-ls command to get the available process name'
        exit 1
    fi
    process=${ARGS[0]}
    command="overmind log ${process}"
    echo_info "\nExecuting the command:\n$command\n"
    eval "$command"
    echo_info "$process log done"
}

function psRestart(){
  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The process name should be given as first argument'
      echo_err 'use the ps-ls command to get the available process name'
      exit 1
  fi
  process=${ARGS[0]}
  command="overmind restart ${process}"
  sleep 5 && overmind restart sql_exporter; cat /proc/1/fd/1 /proc/1/fd/2
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"
  echo_info "$process restarted"
}

function psState(){
  supervisorctl status
}

function dbSqlRestore(){
  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The Snapshot Id should be given as first argument'
      echo_err 'use the dump-ls command to get the available snapshot id'
      # shellcheck disable=SC2016
      echo_err 'or use `latest` if you want to use the latest snapshot'
      exit 1
  fi
  snapshot=${ARGS[0]}
  targetDbName=${ARGS[1]}
  if [ -z "${targetDbName}" ]; then
      targetDbName=$CTL_DATABASE_NAME
  fi

  echo_info "Restoring the dump (${DB_DUMP_SQL_FILE}) from the snapshot ${snapshot} into the database (${targetDbName})"
  command="restic restore --include ${DB_DUMP_SQL_FILE} --target $RESTORE_DIR_BASE --verify ${snapshot}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"
  echo_info "Restoration done"

  dumpFileToRestore="${RESTORE_DIR_BASE}${DB_DUMP_SQL_FILE}"
  echo_info "Restoring the database ${targetDbName} with the dump (${dumpFileToRestore}) into the database (${targetDbName})"
  RESULT=$(psql -tAc "SELECT 1 FROM pg_database WHERE datname='${targetDbName}'")
  if [ "$RESULT" == "1" ]; then
    echo_info "The database ${targetDbName} exits and should be dropped before restoration"
    echo_info "Dropping the database ${targetDbName} before restoration"
    command="dropdb ${targetDbName} --force -i"
    echo_info "\nExecuting the command:\n$command\n"
    eval "$command"
    echo_info "Done"
  fi;
  echo_info "Creating the database ${targetDbName}"
  # load the output of pg_restore into a truly empty database (ie template0)
  createdb -T template0 "${targetDbName}"
  echo_info "Done"
  echo_info "Executing the Sql dump"
  gunzip < "${dumpFileToRestore}" | psql --set ON_ERROR_STOP=on --single-transaction "${targetDbName}"
  echo_info "Done"
  echo_info "Restoration done and successful"
}

function dbArchiveRestore(){
  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The Snapshot Id should be given as first argument'
      echo_err 'use the dump-ls command to get the available snapshot ids'
      # shellcheck disable=SC2016
      echo_err 'or use `latest` if you want to use the latest snapshot'
      exit 1
  fi
  snapshot=${ARGS[0]}
  targetDbName=${ARGS[1]}
  if [ -z "${targetDbName}" ]; then
      targetDbName=$CTL_DATABASE_NAME
  fi
  echo_info "Fetching the dump (${DB_DUMP_ARCHIVE_FILE}) from the snapshot ${snapshot} into the database (${targetDbName})"
  restic restore --include "${DB_DUMP_ARCHIVE_FILE}" --target "$RESTORE_DIR_BASE" --verify "${snapshot}"
  echo_info "Fetching done"
  dumpFileToRestore="${RESTORE_DIR_BASE}${DB_DUMP_ARCHIVE_FILE}"
  echo_info "Restoring the database ${targetDbName} with the dump (${dumpFileToRestore}) into the database (${targetDbName})"
  RESULT=$(psql -tAc "SELECT 1 FROM pg_database WHERE datname='${targetDbName}'")
  if [ "$RESULT" == "1" ]; then
    echo_info "The database ${targetDbName} exits and should be dropped before restoration"
    echo_info "Dropping the database ${targetDbName} before restoration? (y/N)"
    read -r answer
    if [ "$answer" != "y" ]; then
        echo "Exiting..."
        exit
    fi
    dropdb "${targetDbName}" --force -i
    echo_info "Done"
  fi;
  echo_info "Creating the database ${targetDbName}"
  # load the output of pg_restore into a truly empty database (ie template0)
  createdb -T template0 "${targetDbName}"
  echo_info "Done"
  echo_info "Executing the Archive dump"

  # the -d option makes a direct connection with libpq
  # If the connection does not work, try with psql
  command="pg_restore -d ${targetDbName} ${dumpFileToRestore}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Done"
  echo_info "Restoration done and successful"
}

function dbSqlDump(){
  echo_info "Dumping the database (${CTL_DATABASE_NAME})"

  command="pg_dump ${CTL_DATABASE_NAME} | gzip  > ${DB_DUMP_SQL_FILE}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Done"
  echo_info "Loading into Restic S3 repo (${PG_DUMP_DATA})"

  command="restic backup ${PG_DUMP_DATA}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Restic upload done"
  echo_info "Backup done"

}

function dbArchiveDump(){

  echo_info "Dumping the database (${CTL_DATABASE_NAME}) at ${DB_DUMP_ARCHIVE_FILE}"

  # F means format and c specify the custom format
  # https://www.postgresql.org/docs/current/app-pgdump.html
  command="pg_dump --format=c ${CTL_DATABASE_NAME} > ${DB_DUMP_ARCHIVE_FILE}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Done"
  echo_info "Loading into Restic S3 repo (${PG_DUMP_DATA})"

  command="restic backup ${PG_DUMP_DATA}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Restic upload done"
  echo_info "Backup done"
}

function dbDirDump(){

  echo_info "Dumping the database (${CTL_DATABASE_NAME}) at ${DB_DUMP_ARCHIVE_DIR}"
  echo_info "Removing ${DB_DUMP_ARCHIVE_DIR}"
  rm -f "${DB_DUMP_ARCHIVE_DIR}"/*
  if [ -d "${DB_DUMP_ARCHIVE_DIR}" ]; then
      rmdir "${DB_DUMP_ARCHIVE_DIR}"
  fi

  # F means format and d specify the directory format
  # https://www.postgresql.org/docs/current/app-pgdump.html
  command="pg_dump --format=d ${CTL_DATABASE_NAME} -f ${DB_DUMP_ARCHIVE_DIR}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Done"
  echo_info "Loading into Restic S3 repo (${PG_DUMP_DATA})"

  command="restic backup ${PG_DUMP_DATA}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Restic upload done"
  echo_info "Backup done"
}

function dumpLs(){
  restic find --long  "${PG_DUMP_DATA}"
}

function dumpFetch(){

  if [ -z "${ARGS[0]}" ]; then
      echo_err 'The Snapshot Id should be given as first argument'
      echo_err 'use the dump-ls command to get the available snapshot ids'
      # shellcheck disable=SC2016
      echo_err 'or use `latest` if you want to use the latest snapshot'
      exit 1
  fi
  snapshot=${ARGS[0]}
  if [ -z "${ARGS[1]}" ]; then
      echo_err 'A path should be given as second argument'
      exit 1
  fi
  path=${ARGS[1]}
  echo_info "Fetching the path (${path}) from the snapshot id ${snapshot}"

  command="restic restore --include ${path} --target $RESTORE_DIR_BASE --verify ${snapshot}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  targetDumpFileInRestore="${RESTORE_DIR_BASE}${path}"
  echo_info "Fetch done"
  echo_info "The restored file is available at ${targetDumpFileInRestore}"

}

function walGRestore(){

  overmind stop postgres
  overmind restart postgres
  overmind log postgres
  stop_word="recovered"

  # 2 options: strace of snoops a tty
  # read the stdout (fd/1) and stderr (fd/2) of overmind (proc/1)
  # pb the PID on restart are not the same
  # https://github.com/tmux/tmux/wiki/Control-Mode/fd5e33023fe7c16cb573b954d05c70e16d225a9a#pane-output
  # debug the process (e.g. strace, dtrace/dtruss, gdb, lldb, ...)
  # strace works using the ptrace system call, so if ptrace isn’t allowed
  # ptrace needs to be allowed via a switch to the docker command (ie cap_add: SYS_PTRACE)
  # strace -e trace=write -s 1000 -p 1 2>&1 | while ....
  # ie prints write operation of the process (1000 length) specified by PID (-p 1)
  # https://unix.stackexchange.com/questions/58550/how-to-view-the-output-of-a-running-process-in-another-bash-session
  # watch which snoops a given tty, e.g.
  # watch /dev/pts/0
  # https://github.com/rapiz1/catp/
  # if you cat you just delete from the log the long line
  cat /proc/1/fd/1 /proc/1/fd/2 | while IFS= read -r line
  # you can write to them ls >/proc/1/fd/1
  # https://github.com/DarthSim/overmind/issues/111
  # cat /proc/20/fd/1 /proc/20/fd/2
  do
      echo "$line"
      if [[ "$line" == *"$stop_word"* ]]; then
          break
      fi
  done

}
function dumpPrune(){

  echo_info "Rolling the dump files (forget and prune)"
  command="restic forget --prune ${DBCTL_FORGET_POLICY:---keep-hourly 5 --keep-daily 7 --keep-weekly 5 --keep-monthly 12 --keep-yearly 3}"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Data check with subset"
  COUNTER_FILE="$DATA_HOME/dbctl-check-subset-counter"
  COUNTER_TOTAL=${DBCTL_CHECK_SUBSET:-5}
  if [ ! -f "$COUNTER_FILE" ]; then
      echo 0 > "$COUNTER_FILE"
  fi
  counter=$(cat "$COUNTER_FILE")
  counter=$((counter + 1))
  if [ "$counter" -gt "$COUNTER_TOTAL" ]; then
      counter=1
  fi
  echo "$counter" > "$COUNTER_FILE"

  command="restic check --read-data-subset=$counter/$COUNTER_TOTAL"
  echo_info "\nExecuting the command:\n$command\n"
  eval "$command"

  echo_info "Dump Prune done"
}

#######################################
## Main
#######################################

CLI_NAME=$(basename "$0") # Name of the cli
if [[ -z ${DBCTL_LOG_FILE} ]]; then
  echo_err "The DBCTL_LOG_FILE env is mandatory"
  exit 1
fi

declare -a OPTIONS
declare -a ARGS
COMMAND=""
# Parsing
for arg in "$@"; do
  case "$arg" in
  --*)
    OPTIONS+=("$arg")
    shift
    ;;
  *)
    # Command
    if [ -z "$COMMAND" ]; then
      COMMAND="$arg"
      echo "Command ($COMMAND) found"
    else
      echo "Arg ($arg) found"
      ARGS+=("$arg")
    fi
    shift
    ;;
  esac
done

if [ "$COMMAND" == "" ]; then
  echo 'No command was given, help chosen.'
  COMMAND='help'
fi

## Global Parameters
CTL_DATABASE_NAME=${POSTGRES_DB}
if [ -z "${CTL_DATABASE_NAME}" ]; then
  CTL_DATABASE_NAME=${POSTGRES_USER}
fi;
if [ -z "${CTL_DATABASE_NAME}" ]; then
  echo_err "The database could not be determined via POSTGRES_DB or POSTGRES_USER"
  exit 1;
fi;

## Dump parameter
if [[ -z ${PG_DUMP_DATA} ]]; then
    echo_err "The PG_DUMP_DATA var is unknown"
    exit 1;
fi;
mkdir -p "$PG_DUMP_DATA"
DB_DUMP_SQL_FILE="$PG_DUMP_DATA"/dumpfile-db-"${CTL_DATABASE_NAME}".sql.gz
DB_DUMP_ARCHIVE_FILE="$PG_DUMP_DATA"/dumpfile-db-"${CTL_DATABASE_NAME}".dump
DB_DUMP_ARCHIVE_DIR="$PG_DUMP_DATA"/dumpfile-db-"${CTL_DATABASE_NAME}"
# RESTORE_DIR_BASE where the files restored are going
RESTORE_DIR_BASE=/tmp

echo
echo "${CLI_NAME^} ${COMMAND^}"
echo "-------------------------------------------"
echo ""
case ${COMMAND} in
db-backup-sql-dump)
  dbSqlDump
  ;;
db-backup-sql-restore)
  dbSqlRestore
  ;;
db-backup-archive-dump)
  dbArchiveDump
  ;;
db-backup-archive-restore)
  dbArchiveRestore
  ;;
db-backp-dir-dump)
  dbDirDump
  ;;
dump-fetch)
  dumpFetch
  ;;
dump-ls)
  dumpLs
  ;;
dump-prune)
  dumpPrune
  ;;
db-ls)
  psql -c "\l"
  ;;
wal-ls)
  psql -c "select * from pg_stat_archiver"
#  psql -c "SELECT pg_switch_wal()"
  psql -c "SHOW archive_mode; SHOW archive_command"
  ;;
db-extension-ls)
  psql -c "\dx"
  ;;
ps-ls)
  psLs
  ;;
ps-restart)
  psRestart
  ;;
ps-start)
  psStart
  ;;
ps-log)
  psLog
  ;;
db-conf)
  cat /etc/postgresql/postgresql.conf
  ;;
pg)
  pg_ctl "${OPTIONS[@]}"
  ;;
psql)
  psql "${OPTIONS[@]}"
  ;;
job-ls)
  psql -c "select * from cron.job_run_details order by start_time desc limit 5"
  ;;
help)
  print_usage
  ;;
*)
  echo_err "The command $COMMAND is unknown"
  print_usage
  exit 1
  ;;
esac
